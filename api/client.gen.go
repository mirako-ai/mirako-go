// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AsyncGenerateImageApiRequestBodyAspectRatio.
const (
	AsyncGenerateImageApiRequestBodyAspectRatioN11  AsyncGenerateImageApiRequestBodyAspectRatio = "1:1"
	AsyncGenerateImageApiRequestBodyAspectRatioN169 AsyncGenerateImageApiRequestBodyAspectRatio = "16:9"
	AsyncGenerateImageApiRequestBodyAspectRatioN23  AsyncGenerateImageApiRequestBodyAspectRatio = "2:3"
	AsyncGenerateImageApiRequestBodyAspectRatioN32  AsyncGenerateImageApiRequestBodyAspectRatio = "3:2"
	AsyncGenerateImageApiRequestBodyAspectRatioN34  AsyncGenerateImageApiRequestBodyAspectRatio = "3:4"
	AsyncGenerateImageApiRequestBodyAspectRatioN43  AsyncGenerateImageApiRequestBodyAspectRatio = "4:3"
	AsyncGenerateImageApiRequestBodyAspectRatioN916 AsyncGenerateImageApiRequestBodyAspectRatio = "9:16"
)

// Defines values for AsyncTaskStatusStatus.
const (
	AsyncTaskStatusStatusCANCELED   AsyncTaskStatusStatus = "CANCELED"
	AsyncTaskStatusStatusCOMPLETED  AsyncTaskStatusStatus = "COMPLETED"
	AsyncTaskStatusStatusFAILED     AsyncTaskStatusStatus = "FAILED"
	AsyncTaskStatusStatusINPROGRESS AsyncTaskStatusStatus = "IN_PROGRESS"
	AsyncTaskStatusStatusINQUEUE    AsyncTaskStatusStatus = "IN_QUEUE"
	AsyncTaskStatusStatusTIMEDOUT   AsyncTaskStatusStatus = "TIMED_OUT"
)

// Defines values for AvatarResponseStatus.
const (
	BUILDING AvatarResponseStatus = "BUILDING"
	ERROR    AvatarResponseStatus = "ERROR"
	PENDING  AvatarResponseStatus = "PENDING"
	READY    AvatarResponseStatus = "READY"
)

// Defines values for FinetuningTaskOutputStatus.
const (
	FinetuningTaskOutputStatusCANCELED   FinetuningTaskOutputStatus = "CANCELED"
	FinetuningTaskOutputStatusCOMPLETED  FinetuningTaskOutputStatus = "COMPLETED"
	FinetuningTaskOutputStatusFAILED     FinetuningTaskOutputStatus = "FAILED"
	FinetuningTaskOutputStatusINPROGRESS FinetuningTaskOutputStatus = "IN_PROGRESS"
	FinetuningTaskOutputStatusINQUEUE    FinetuningTaskOutputStatus = "IN_QUEUE"
	FinetuningTaskOutputStatusTIMEDOUT   FinetuningTaskOutputStatus = "TIMED_OUT"
)

// Defines values for GenerateAvatarMotionTaskOutputStatus.
const (
	GenerateAvatarMotionTaskOutputStatusCANCELED   GenerateAvatarMotionTaskOutputStatus = "CANCELED"
	GenerateAvatarMotionTaskOutputStatusCOMPLETED  GenerateAvatarMotionTaskOutputStatus = "COMPLETED"
	GenerateAvatarMotionTaskOutputStatusFAILED     GenerateAvatarMotionTaskOutputStatus = "FAILED"
	GenerateAvatarMotionTaskOutputStatusINPROGRESS GenerateAvatarMotionTaskOutputStatus = "IN_PROGRESS"
	GenerateAvatarMotionTaskOutputStatusINQUEUE    GenerateAvatarMotionTaskOutputStatus = "IN_QUEUE"
	GenerateAvatarMotionTaskOutputStatusTIMEDOUT   GenerateAvatarMotionTaskOutputStatus = "TIMED_OUT"
)

// Defines values for GenerateAvatarTaskOutputStatus.
const (
	GenerateAvatarTaskOutputStatusCANCELED   GenerateAvatarTaskOutputStatus = "CANCELED"
	GenerateAvatarTaskOutputStatusCOMPLETED  GenerateAvatarTaskOutputStatus = "COMPLETED"
	GenerateAvatarTaskOutputStatusFAILED     GenerateAvatarTaskOutputStatus = "FAILED"
	GenerateAvatarTaskOutputStatusINPROGRESS GenerateAvatarTaskOutputStatus = "IN_PROGRESS"
	GenerateAvatarTaskOutputStatusINQUEUE    GenerateAvatarTaskOutputStatus = "IN_QUEUE"
	GenerateAvatarTaskOutputStatusTIMEDOUT   GenerateAvatarTaskOutputStatus = "TIMED_OUT"
)

// Defines values for GenerateImageApiRequestBodyAspectRatio.
const (
	GenerateImageApiRequestBodyAspectRatioN11  GenerateImageApiRequestBodyAspectRatio = "1:1"
	GenerateImageApiRequestBodyAspectRatioN169 GenerateImageApiRequestBodyAspectRatio = "16:9"
	GenerateImageApiRequestBodyAspectRatioN23  GenerateImageApiRequestBodyAspectRatio = "2:3"
	GenerateImageApiRequestBodyAspectRatioN32  GenerateImageApiRequestBodyAspectRatio = "3:2"
	GenerateImageApiRequestBodyAspectRatioN34  GenerateImageApiRequestBodyAspectRatio = "3:4"
	GenerateImageApiRequestBodyAspectRatioN43  GenerateImageApiRequestBodyAspectRatio = "4:3"
	GenerateImageApiRequestBodyAspectRatioN916 GenerateImageApiRequestBodyAspectRatio = "9:16"
)

// Defines values for GenerateTalkingAvatarTaskOutputStatus.
const (
	GenerateTalkingAvatarTaskOutputStatusCANCELED   GenerateTalkingAvatarTaskOutputStatus = "CANCELED"
	GenerateTalkingAvatarTaskOutputStatusCOMPLETED  GenerateTalkingAvatarTaskOutputStatus = "COMPLETED"
	GenerateTalkingAvatarTaskOutputStatusFAILED     GenerateTalkingAvatarTaskOutputStatus = "FAILED"
	GenerateTalkingAvatarTaskOutputStatusINPROGRESS GenerateTalkingAvatarTaskOutputStatus = "IN_PROGRESS"
	GenerateTalkingAvatarTaskOutputStatusINQUEUE    GenerateTalkingAvatarTaskOutputStatus = "IN_QUEUE"
	GenerateTalkingAvatarTaskOutputStatusTIMEDOUT   GenerateTalkingAvatarTaskOutputStatus = "TIMED_OUT"
)

// Defines values for GenerateTaskOutputStatus.
const (
	GenerateTaskOutputStatusCANCELED   GenerateTaskOutputStatus = "CANCELED"
	GenerateTaskOutputStatusCOMPLETED  GenerateTaskOutputStatus = "COMPLETED"
	GenerateTaskOutputStatusFAILED     GenerateTaskOutputStatus = "FAILED"
	GenerateTaskOutputStatusINPROGRESS GenerateTaskOutputStatus = "IN_PROGRESS"
	GenerateTaskOutputStatusINQUEUE    GenerateTaskOutputStatus = "IN_QUEUE"
	GenerateTaskOutputStatusTIMEDOUT   GenerateTaskOutputStatus = "TIMED_OUT"
)

// Defines values for StartSessionApiRequestBodyModel.
const (
	Metis25 StartSessionApiRequestBodyModel = "metis-2.5"
)

// Defines values for TTSApiRequestBodyChineseLanguage.
const (
	Mandarin TTSApiRequestBodyChineseLanguage = "mandarin"
	Yue      TTSApiRequestBodyChineseLanguage = "yue"
)

// ApiTokenRecord defines model for ApiTokenRecord.
type ApiTokenRecord struct {
	// AuthTokenType Type of the authentication token used for this API user. Possible values are 'api_token', 'jwt_token'
	AuthTokenType string `json:"auth_token_type"`

	// CreatedAt Creation timestamp of the API token
	CreatedAt time.Time `json:"created_at"`

	// Events List of events associated with the API user, such as transaction events
	Events *map[string]interface{} `json:"events,omitempty"`

	// Hint Hint for the API token, used for displaying in the UI
	Hint string `json:"hint"`

	// IsDelinquent Indicates if the API user is delinquent, e.g., negative credits, unpaid bills
	IsDelinquent bool `json:"is_delinquent"`

	// Label Label for the API token, used for describing the purpose of the token
	Label string `json:"label"`

	// TokenId Unique identifier for the API token. Empty if user authenticated by jwt session.
	TokenId string `json:"token_id"`

	// Type Type of the API user. Default to 'user'
	Type string `json:"type"`

	// UserId User ID of the API token owner
	UserId string `json:"user_id"`
}

// ApiUserMetadata defines model for ApiUserMetadata.
type ApiUserMetadata struct {
	// IsDelinquent Indicates if the API user is delinquent, e.g., negative credits, unpaid bills
	IsDelinquent bool `json:"is_delinquent"`

	// UserId User ID of the API user
	UserId string `json:"user_id"`
}

// AsyncBuildApiRequestBody defines model for AsyncBuildApiRequestBody.
type AsyncBuildApiRequestBody struct {
	// Image The base64 encoded image to build the avatar from
	Image string `json:"image"`

	// Name The name of the avatar
	Name string `json:"name"`
}

// AsyncBuildApiResponseBody defines model for AsyncBuildApiResponseBody.
type AsyncBuildApiResponseBody struct {
	Data *AsyncBuildOutput `json:"data,omitempty"`
}

// AsyncBuildOutput defines model for AsyncBuildOutput.
type AsyncBuildOutput struct {
	// AvatarId The ID of the created avatar
	AvatarId string `json:"avatar_id"`
}

// AsyncFinetuningApiResponseBody defines model for AsyncFinetuningApiResponseBody.
type AsyncFinetuningApiResponseBody struct {
	Data *AsyncTaskStatus `json:"data,omitempty"`
}

// AsyncFinetunningWebhookRequestBody defines model for AsyncFinetunningWebhookRequestBody.
type AsyncFinetunningWebhookRequestBody struct {
	// DelayTime The time taken to process the request
	DelayTime int64 `json:"delayTime"`

	// Error The error message if any
	Error *string `json:"error,omitempty"`

	// ExecutionTime The time taken to process the request
	ExecutionTime int64 `json:"executionTime"`

	// Id The id of the request
	Id     string                    `json:"id"`
	Output *FinetuningOutputInternal `json:"output,omitempty"`

	// Status The status of the request. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
	Status               string                 `json:"status"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AsyncGenerateAvatarApiRequestBody defines model for AsyncGenerateAvatarApiRequestBody.
type AsyncGenerateAvatarApiRequestBody struct {
	// Prompt The prompt for the avatar generation.
	Prompt string `json:"prompt"`

	// Seed Random seed for the generation, if not provided a random seed will be used
	Seed    *int64   `json:"seed,omitempty"`
	Webhook *Webhook `json:"webhook,omitempty"`
}

// AsyncGenerateAvatarApiResponseBody defines model for AsyncGenerateAvatarApiResponseBody.
type AsyncGenerateAvatarApiResponseBody struct {
	Data *AsyncTaskStatus `json:"data,omitempty"`
}

// AsyncGenerateAvatarMotionApiRequestBody defines model for AsyncGenerateAvatarMotionApiRequestBody.
type AsyncGenerateAvatarMotionApiRequestBody struct {
	// Audio The base64 encoded audio file to use as the avatar's speech.
	Audio string `json:"audio"`

	// Image The base64 encoded image to use as the starting frame, which should clearly showing the avatar's face.
	Image string `json:"image"`

	// NegativePrompt The negative prompt to guide the avatar motion generation.
	NegativePrompt string `json:"negative_prompt"`

	// PositivePrompt The positive prompt to guide the avatar motion generation.
	PositivePrompt string   `json:"positive_prompt"`
	Webhook        *Webhook `json:"webhook,omitempty"`
}

// AsyncGenerateAvatarMotionApiResponseBody defines model for AsyncGenerateAvatarMotionApiResponseBody.
type AsyncGenerateAvatarMotionApiResponseBody struct {
	Data *AsyncTaskStatus `json:"data,omitempty"`
}

// AsyncGenerateAvatarWebhookRequestBody defines model for AsyncGenerateAvatarWebhookRequestBody.
type AsyncGenerateAvatarWebhookRequestBody struct {
	// DelayTime The time taken to process the request
	DelayTime int64 `json:"delayTime"`

	// Error The error message if any
	Error *string `json:"error,omitempty"`

	// ExecutionTime The time taken to process the request
	ExecutionTime int64 `json:"executionTime"`

	// Id The id of the request
	Id     string                `json:"id"`
	Output *GenerateAvatarOutput `json:"output,omitempty"`

	// Status The status of the request. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
	Status               string                 `json:"status"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AsyncGenerateImageApiRequestBody defines model for AsyncGenerateImageApiRequestBody.
type AsyncGenerateImageApiRequestBody struct {
	// AspectRatio The aspect ratio for the generation. Default to '16:9'
	AspectRatio AsyncGenerateImageApiRequestBodyAspectRatio `json:"aspect_ratio"`

	// Images Optional. List of labeld images in base64 format for text-image-to-image generation. Maximum 5 images can be provided as input.
	Images *[]LabeledImage `json:"images"`

	// Prompt The prompt for the image generation. Include in the prompt the Avatar Id (uuid) to generate image of the avatar.
	Prompt string `json:"prompt"`

	// Seed Seed for the generation, if not provided a random seed will be used
	Seed    *int32   `json:"seed,omitempty"`
	Webhook *Webhook `json:"webhook,omitempty"`
}

// AsyncGenerateImageApiRequestBodyAspectRatio The aspect ratio for the generation. Default to '16:9'
type AsyncGenerateImageApiRequestBodyAspectRatio string

// AsyncGenerateImageApiResponseBody defines model for AsyncGenerateImageApiResponseBody.
type AsyncGenerateImageApiResponseBody struct {
	Data *AsyncTaskStatus `json:"data,omitempty"`
}

// AsyncGenerateTalkingAvatarApiRequestBody defines model for AsyncGenerateTalkingAvatarApiRequestBody.
type AsyncGenerateTalkingAvatarApiRequestBody struct {
	// Audio The base64 encoded audio file to use as the avatar's speech.
	Audio string `json:"audio"`

	// Image The base64 encoded image to use as the avatar's face.
	Image   string   `json:"image"`
	Webhook *Webhook `json:"webhook,omitempty"`
}

// AsyncGenerateTalkingAvatarApiResponseBody defines model for AsyncGenerateTalkingAvatarApiResponseBody.
type AsyncGenerateTalkingAvatarApiResponseBody struct {
	Data *AsyncTaskStatus `json:"data,omitempty"`
}

// AsyncTaskStatus defines model for AsyncTaskStatus.
type AsyncTaskStatus struct {
	// Status The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
	Status AsyncTaskStatusStatus `json:"status"`

	// TaskId The id of the async task
	TaskId string `json:"task_id"`
}

// AsyncTaskStatusStatus The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
type AsyncTaskStatusStatus string

// AvatarResponse defines model for AvatarResponse.
type AvatarResponse struct {
	// CreatedAt Creation timestamp of the avatar
	CreatedAt time.Time `json:"created_at"`

	// Id Unique identifier for the avatar
	Id string `json:"id"`

	// Name Name of the avatar
	Name string `json:"name"`

	// Status Status of the avatar, either 'PENDING', 'BUILDING', 'READY' or 'ERROR'
	Status AvatarResponseStatus `json:"status"`

	// Themes Avatar themes are the different appearances of the avatar, each with its own key image and live video.
	Themes *[]PresignedAvatarTheme `json:"themes"`

	// UserId User ID of the owner of this avatar
	UserId string `json:"user_id"`
}

// AvatarResponseStatus Status of the avatar, either 'PENDING', 'BUILDING', 'READY' or 'ERROR'
type AvatarResponseStatus string

// CreateApiTokenOutput defines model for CreateApiTokenOutput.
type CreateApiTokenOutput struct {
	// AuthTokenType Type of the authentication token used for this API user. Possible values are 'api_token', 'jwt_token'
	AuthTokenType string `json:"auth_token_type"`

	// CreatedAt Creation timestamp of the API token
	CreatedAt time.Time `json:"created_at"`

	// Events List of events associated with the API user, such as transaction events
	Events *map[string]interface{} `json:"events,omitempty"`

	// Hint Hint for the API token, used for displaying in the UI
	Hint string `json:"hint"`

	// IsDelinquent Indicates if the API user is delinquent, e.g., negative credits, unpaid bills
	IsDelinquent bool `json:"is_delinquent"`

	// Label Label for the API token, used for describing the purpose of the token
	Label string `json:"label"`
	Token string `json:"token"`

	// TokenId Unique identifier for the API token. Empty if user authenticated by jwt session.
	TokenId string `json:"token_id"`

	// Type Type of the API user. Default to 'user'
	Type string `json:"type"`

	// UserId User ID of the API token owner
	UserId string `json:"user_id"`
}

// CreateTokenApiRequestBody defines model for CreateTokenApiRequestBody.
type CreateTokenApiRequestBody struct {
	// Label Label for the API token
	Label string `json:"label"`
}

// CreateTokenApiResponseBody defines model for CreateTokenApiResponseBody.
type CreateTokenApiResponseBody struct {
	Data CreateApiTokenOutput `json:"data"`
}

// DataStruct defines model for DataStruct.
type DataStruct = map[string]interface{}

// DeleteVoiceProfileApiResponseBody defines model for DeleteVoiceProfileApiResponseBody.
type DeleteVoiceProfileApiResponseBody struct {
	Data DataStruct `json:"data"`
}

// DummyResponseToTriggerTransformerBody defines model for DummyResponseToTriggerTransformerBody.
type DummyResponseToTriggerTransformerBody struct {
	// Message A dummy response
	Message string `json:"message"`
}

// ErrorDetail defines model for ErrorDetail.
type ErrorDetail struct {
	// Location Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
	Location *string `json:"location,omitempty"`

	// Message Error message text
	Message *string `json:"message,omitempty"`

	// Value The value at the given location
	Value interface{} `json:"value,omitempty"`
}

// ErrorModel defines model for ErrorModel.
type ErrorModel struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Errors Optional list of individual error details
	Errors *[]ErrorDetail `json:"errors"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code
	Status *int64 `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
	Title *string `json:"title,omitempty"`

	// Type A URI reference to human-readable documentation for the error.
	Type *string `json:"type,omitempty"`
}

// FinetuningMetadata defines model for FinetuningMetadata.
type FinetuningMetadata struct {
	Extra    map[string]interface{} `json:"Extra"`
	RefAudio *RemoteFile            `json:"ref_audio,omitempty"`
}

// FinetuningOutputInternal defines model for FinetuningOutputInternal.
type FinetuningOutputInternal struct {
	Error    *string             `json:"error,omitempty"`
	Id       *string             `json:"id,omitempty"`
	MetaData *FinetuningMetadata `json:"meta_data,omitempty"`

	// ModelInferParams The inference parameters for the model
	ModelInferParams *map[string]interface{} `json:"model_infer_params,omitempty"`
	ProfileId        *string                 `json:"profile_id,omitempty"`
	TrainTime        float32                 `json:"train_time"`
}

// FinetuningStatusApiResponseBody defines model for FinetuningStatusApiResponseBody.
type FinetuningStatusApiResponseBody struct {
	Data *FinetuningTaskOutput `json:"data,omitempty"`
}

// FinetuningTaskOutput defines model for FinetuningTaskOutput.
type FinetuningTaskOutput struct {
	// Error Error message if any
	Error *string `json:"error,omitempty"`

	// MetaData Additional metadata about the finetuning process
	MetaData *map[string]interface{} `json:"meta_data,omitempty"`

	// ProfileId The profile ID of the custom voice model
	ProfileId *string `json:"profile_id,omitempty"`

	// Status The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
	Status FinetuningTaskOutputStatus `json:"status"`

	// TaskId The id of the async task
	TaskId string `json:"task_id"`
}

// FinetuningTaskOutputStatus The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
type FinetuningTaskOutputStatus string

// GenerateAvatarMotionOutputInternal defines model for GenerateAvatarMotionOutputInternal.
type GenerateAvatarMotionOutputInternal struct {
	// EngineProcessingTime Model inference time in seconds.
	EngineProcessingTime *float32 `json:"engine_processing_time,omitempty"`

	// Error Error message if any
	Error *string `json:"error,omitempty"`

	// OutputDuration The duration of the output video in seconds.
	OutputDuration *float64 `json:"output_duration,omitempty"`

	// ProcessingInfo Additional info about the processing.
	ProcessingInfo *string `json:"processing_info,omitempty"`

	// RequestId The id of the request
	RequestId string `json:"request_id"`

	// ResultB64Str The base64-encoded MP4 video output. Only available when the result_type is 'b64_str'.
	ResultB64Str *string     `json:"result_b64_str,omitempty"`
	ResultS3Info *RemoteFile `json:"result_s3_info,omitempty"`

	// TotalProcessingTime Total processing time in seconds.
	TotalProcessingTime *float32 `json:"total_processing_time,omitempty"`
}

// GenerateAvatarMotionStatusApiResponseBody defines model for GenerateAvatarMotionStatusApiResponseBody.
type GenerateAvatarMotionStatusApiResponseBody struct {
	Data *GenerateAvatarMotionTaskOutput `json:"data,omitempty"`
}

// GenerateAvatarMotionTaskOutput defines model for GenerateAvatarMotionTaskOutput.
type GenerateAvatarMotionTaskOutput struct {
	// Error Error message if any
	Error *string `json:"error,omitempty"`

	// FileUrl The URL of the output MP4 video.
	FileUrl *string `json:"file_url,omitempty"`

	// OutputDuration The duration of the output video in seconds.
	OutputDuration *float64 `json:"output_duration,omitempty"`

	// Status The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
	Status GenerateAvatarMotionTaskOutputStatus `json:"status"`

	// TaskId The id of the async task
	TaskId string `json:"task_id"`
}

// GenerateAvatarMotionTaskOutputStatus The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
type GenerateAvatarMotionTaskOutputStatus string

// GenerateAvatarMotionWebhookRequestBody defines model for GenerateAvatarMotionWebhookRequestBody.
type GenerateAvatarMotionWebhookRequestBody struct {
	// DelayTime The time taken to process the request
	DelayTime int64 `json:"delayTime"`

	// Error The error message if any
	Error *string `json:"error,omitempty"`

	// ExecutionTime The time taken to process the request
	ExecutionTime int64 `json:"executionTime"`

	// Id The id of the request
	Id     string                              `json:"id"`
	Output *GenerateAvatarMotionOutputInternal `json:"output,omitempty"`

	// Status The status of the request. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
	Status               string                 `json:"status"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GenerateAvatarOutput defines model for GenerateAvatarOutput.
type GenerateAvatarOutput struct {
	// Image The generated avatar image, in base64 format
	Image *string `json:"image,omitempty"`
}

// GenerateAvatarStatusApiResponseBody defines model for GenerateAvatarStatusApiResponseBody.
type GenerateAvatarStatusApiResponseBody struct {
	Data *GenerateAvatarTaskOutput `json:"data,omitempty"`
}

// GenerateAvatarTaskOutput defines model for GenerateAvatarTaskOutput.
type GenerateAvatarTaskOutput struct {
	// Image The generated avatar image, in base64 format
	Image *string `json:"image,omitempty"`

	// Status The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
	Status GenerateAvatarTaskOutputStatus `json:"status"`

	// TaskId The id of the async task
	TaskId string `json:"task_id"`
}

// GenerateAvatarTaskOutputStatus The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
type GenerateAvatarTaskOutputStatus string

// GenerateImageApiRequestBody defines model for GenerateImageApiRequestBody.
type GenerateImageApiRequestBody struct {
	// AspectRatio The aspect ratio for the generation. Default to '16:9'
	AspectRatio GenerateImageApiRequestBodyAspectRatio `json:"aspect_ratio"`

	// Images Optional. List of labeld images in base64 format for text-image-to-image generation. Maximum 5 images can be provided as input.
	Images *[]LabeledImage `json:"images"`

	// Prompt The prompt for the image generation. Include in the prompt the Avatar Id (uuid) to generate image of the avatar.
	Prompt string `json:"prompt"`

	// Seed Seed for the generation, if not provided a random seed will be used
	Seed *int32 `json:"seed,omitempty"`
}

// GenerateImageApiRequestBodyAspectRatio The aspect ratio for the generation. Default to '16:9'
type GenerateImageApiRequestBodyAspectRatio string

// GenerateImageApiResponseBody defines model for GenerateImageApiResponseBody.
type GenerateImageApiResponseBody struct {
	Data *GenerateOutput `json:"data,omitempty"`
}

// GenerateImageStatusApiResponseBody defines model for GenerateImageStatusApiResponseBody.
type GenerateImageStatusApiResponseBody struct {
	Data *GenerateTaskOutput `json:"data,omitempty"`
}

// GenerateOutput defines model for GenerateOutput.
type GenerateOutput struct {
	// Image The generated image in JPG format, encoded in base64.
	Image *string `json:"image,omitempty"`
}

// GenerateTalkingAvatarOutputInternal defines model for GenerateTalkingAvatarOutputInternal.
type GenerateTalkingAvatarOutputInternal struct {
	B64VideoStr *string `json:"b64_video_str,omitempty"`

	// Error Error message if any
	Error     *string `json:"error,omitempty"`
	Id        string  `json:"id"`
	InferTime float32 `json:"infer_time"`

	// OutputDuration The duration of the output video in seconds.
	OutputDuration *float64    `json:"output_duration,omitempty"`
	S3Info         *RemoteFile `json:"s3_info,omitempty"`
}

// GenerateTalkingAvatarStatusApiResponseBody defines model for GenerateTalkingAvatarStatusApiResponseBody.
type GenerateTalkingAvatarStatusApiResponseBody struct {
	Data *GenerateTalkingAvatarTaskOutput `json:"data,omitempty"`
}

// GenerateTalkingAvatarTaskOutput defines model for GenerateTalkingAvatarTaskOutput.
type GenerateTalkingAvatarTaskOutput struct {
	// Error Error message if any
	Error *string `json:"error,omitempty"`

	// FileUrl The URL of the output MP4 video.
	FileUrl *string `json:"file_url,omitempty"`

	// OutputDuration The duration of the output video in seconds.
	OutputDuration *float64 `json:"output_duration,omitempty"`

	// Status The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
	Status GenerateTalkingAvatarTaskOutputStatus `json:"status"`

	// TaskId The id of the async task
	TaskId string `json:"task_id"`
}

// GenerateTalkingAvatarTaskOutputStatus The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
type GenerateTalkingAvatarTaskOutputStatus string

// GenerateTalkingAvatarWebhookRequestBody defines model for GenerateTalkingAvatarWebhookRequestBody.
type GenerateTalkingAvatarWebhookRequestBody struct {
	// DelayTime The time taken to process the request
	DelayTime int64 `json:"delayTime"`

	// Error The error message if any
	Error *string `json:"error,omitempty"`

	// ExecutionTime The time taken to process the request
	ExecutionTime int64 `json:"executionTime"`

	// Id The id of the request
	Id     string                               `json:"id"`
	Output *GenerateTalkingAvatarOutputInternal `json:"output,omitempty"`

	// Status The status of the request. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
	Status               string                 `json:"status"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GenerateTaskOutput defines model for GenerateTaskOutput.
type GenerateTaskOutput struct {
	// Image The generated image in JPG format, encoded in base64.
	Image *string `json:"image,omitempty"`

	// Status The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
	Status GenerateTaskOutputStatus `json:"status"`

	// TaskId The id of the async task
	TaskId string `json:"task_id"`
}

// GenerateTaskOutputStatus The status of the async task. Possible values are 'IN_QUEUE', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'CANCELED', 'TIMED_OUT'
type GenerateTaskOutputStatus string

// GetApiUserMetadataResponseBody defines model for GetApiUserMetadataResponseBody.
type GetApiUserMetadataResponseBody struct {
	Data ApiUserMetadata `json:"data"`
}

// GetAvatarApiResponseBody defines model for GetAvatarApiResponseBody.
type GetAvatarApiResponseBody struct {
	Data AvatarResponse `json:"data"`
}

// GetAvatarSystemProfileApiResponseBody defines model for GetAvatarSystemProfileApiResponseBody.
type GetAvatarSystemProfileApiResponseBody struct {
	Data PresignedAvatarSystemProfile `json:"data"`
}

// GetPremadeProfilesApiResponseBody defines model for GetPremadeProfilesApiResponseBody.
type GetPremadeProfilesApiResponseBody struct {
	// Data List of premade voice profiles
	Data *[]PresignedVoiceProfile `json:"data"`
}

// GetSessionProfileApiResponseBody defines model for GetSessionProfileApiResponseBody.
type GetSessionProfileApiResponseBody struct {
	Data *MetisSessionProfile `json:"data,omitempty"`
}

// GetSystemProfileApiResponseBody defines model for GetSystemProfileApiResponseBody.
type GetSystemProfileApiResponseBody struct {
	Data *PresignedVoiceSystemProfile `json:"data,omitempty"`
}

// GetUserAvatarListApiResponseBody defines model for GetUserAvatarListApiResponseBody.
type GetUserAvatarListApiResponseBody struct {
	// Data List of avatars for the user
	Data *[]AvatarResponse `json:"data"`
}

// GetVoiceProfileApiResponseBody defines model for GetVoiceProfileApiResponseBody.
type GetVoiceProfileApiResponseBody struct {
	Data PresignedVoiceProfile `json:"data"`
}

// GetVoiceProfilesApiResponseBody defines model for GetVoiceProfilesApiResponseBody.
type GetVoiceProfilesApiResponseBody struct {
	// Data List of user custom voice profiles
	Data *[]PresignedVoiceProfile `json:"data"`
}

// LabeledImage defines model for LabeledImage.
type LabeledImage struct {
	// Data The image in data-url base64 format. Currently support 'image/jpeg' and 'image/png' format.
	Data string `json:"data"`

	// Label The label of the image. Used to identify and refer the image in the given prompt.
	Label *string `json:"label,omitempty"`
}

// LaunchApiRequestBody defines model for LaunchApiRequestBody.
type LaunchApiRequestBody struct {
	// Model The interactive model version to be launched.
	Model string `json:"model"`

	// Opts Additional options for the instance launch, such as countryCode, gpuTypeIds etc
	Opts *map[string]interface{} `json:"opts,omitempty"`

	// SessionGroup The session group name for the instance. Default session group will be used if it left unspecfied or empty.
	SessionGroup *string `json:"session_group,omitempty"`
}

// LaunchApiResponseBody defines model for LaunchApiResponseBody.
type LaunchApiResponseBody struct {
	Data *MetisInstance `json:"data,omitempty"`
}

// ListApiTokensApiResponseBody defines model for ListApiTokensApiResponseBody.
type ListApiTokensApiResponseBody struct {
	// Data List of API tokens for the user
	Data *[]ApiTokenRecord `json:"data"`
}

// ListSessionsApiResponseBody defines model for ListSessionsApiResponseBody.
type ListSessionsApiResponseBody struct {
	// Data List of active interactive sessions
	Data *[]MetisSession `json:"data"`
}

// Machine defines model for Machine.
type Machine struct {
	CpuTypeId        *string     `json:"cpuTypeId,omitempty"`
	GpuAvailable     *int64      `json:"gpuAvailable,omitempty"`
	GpuTypeId        *string     `json:"gpuTypeId,omitempty"`
	MaintenanceEnd   *RunpodTime `json:"maintenanceEnd,omitempty"`
	MaintenanceNote  *string     `json:"maintenanceNote,omitempty"`
	MaintenanceStart *RunpodTime `json:"maintenanceStart,omitempty"`
	SecureCloud      *bool       `json:"secureCloud,omitempty"`
}

// MetisInstance defines model for MetisInstance.
type MetisInstance struct {
	InstanceId string     `json:"instance_id"`
	LaunchTime *time.Time `json:"launch_time,omitempty"`
	Machine    *Machine   `json:"machine,omitempty"`
	MetisModel string     `json:"metis_model"`
	State      string     `json:"state"`
	UserId     *string    `json:"user_id,omitempty"`
}

// MetisSession defines model for MetisSession.
type MetisSession struct {
	Avatar MetisSessionAvatar `json:"avatar"`

	// IdleTimeout Idle timeout duration in minutes
	IdleTimeout *int64 `json:"idle_timeout,omitempty"`

	// MetisModel The Metis model used in the session
	MetisModel *string `json:"metis_model,omitempty"`

	// SessionId Unique identifier for the session
	SessionId *string `json:"session_id,omitempty"`

	// StartTime Timestamp when the session started in RFC3339 format
	StartTime time.Time `json:"start_time"`

	// State Current state of the session
	State *string `json:"state,omitempty"`

	// UserId User ID of the session owner
	UserId *string `json:"user_id,omitempty"`
}

// MetisSessionAvatar defines model for MetisSessionAvatar.
type MetisSessionAvatar struct {
	// Id Unique identifier for the avatar
	Id *string `json:"id,omitempty"`

	// Name Name of the avatar
	Name *string `json:"name,omitempty"`
}

// MetisSessionProfile defines model for MetisSessionProfile.
type MetisSessionProfile struct {
	Avatar       PresignedAvatarSystemProfile `json:"avatar"`
	SessionId    string                       `json:"session_id"`
	SessionToken string                       `json:"session_token"`
}

// PresignedAvatarSystemProfile defines model for PresignedAvatarSystemProfile.
type PresignedAvatarSystemProfile struct {
	Id           string    `json:"id"`
	Image        *string   `json:"image,omitempty"`
	Liveportrait *[]string `json:"liveportrait"`
	Name         string    `json:"name"`
}

// PresignedAvatarTheme defines model for PresignedAvatarTheme.
type PresignedAvatarTheme struct {
	// KeyImage URL of the key portrait image of the avatar in this theme.
	KeyImage *string `json:"key_image,omitempty"`

	// LiveVideo URL of the live video for the avatar in this theme.
	LiveVideo *string `json:"live_video,omitempty"`

	// Name Name of the avatar theme
	Name string `json:"name"`
}

// PresignedVoiceProfile defines model for PresignedVoiceProfile.
type PresignedVoiceProfile struct {
	// CreatedAt The creation date of the voice profile.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Description The description of the voice profile.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the voice profile.
	Id string `json:"id"`

	// IsPremade Whether the voice profile is a default premade profile.
	IsPremade *bool `json:"is_premade,omitempty"`

	// Languages The languages supported by the voice profile.
	Languages *[]string `json:"languages"`

	// Name The name of the voice profile.
	Name *string `json:"name,omitempty"`

	// SampleClip The URL of a sample audio clip for the voice profile.
	SampleClip *string `json:"sample_clip,omitempty"`

	// Status The status of the voice profile.
	Status *string `json:"status,omitempty"`

	// UserId The user ID of the owner associated with the voice profile.
	UserId *string `json:"user_id,omitempty"`
}

// PresignedVoiceSystemProfile defines model for PresignedVoiceSystemProfile.
type PresignedVoiceSystemProfile struct {
	// CreatedAt The creation date of the voice profile.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Description The description of the voice profile.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the voice profile.
	Id string `json:"id"`

	// IsPremade Whether the voice profile is a default premade profile.
	IsPremade *bool `json:"is_premade,omitempty"`

	// Languages The languages supported by the voice profile.
	Languages *[]string `json:"languages"`

	// Name The name of the voice profile.
	Name *string `json:"name,omitempty"`

	// Params The parameters used for the voice model.
	Params *map[string]interface{} `json:"params,omitempty"`

	// SampleClip The URL of a sample audio clip for the voice profile.
	SampleClip *string `json:"sample_clip,omitempty"`

	// ServiceName The name of the voice service used for this profile.
	ServiceName *string `json:"service_name,omitempty"`

	// Status The status of the voice profile.
	Status *string `json:"status,omitempty"`

	// UserId The user ID of the owner associated with the voice profile.
	UserId *string `json:"user_id,omitempty"`
}

// PrivateApiResponseBody defines model for PrivateApiResponseBody.
type PrivateApiResponseBody struct {
	// Message A simple hello world message for private API access
	Message string `json:"message"`
}

// RemoteFile defines model for RemoteFile.
type RemoteFile struct {
	Bucket string `json:"bucket"`
	Key    string `json:"key"`
	Region string `json:"region"`
}

// RunpodTime defines model for RunpodTime.
type RunpodTime = map[string]interface{}

// STTApiRequestBody defines model for STTApiRequestBody.
type STTApiRequestBody struct {
	// Audio Base64 encoded audio data
	Audio string `json:"audio"`
}

// STTApiResponseBody defines model for STTApiResponseBody.
type STTApiResponseBody struct {
	Data *STTOutput `json:"data,omitempty"`
}

// STTOutput defines model for STTOutput.
type STTOutput struct {
	// Id The unique request ID
	Id string `json:"id"`

	// InputDuration The duration of the input audio in seconds.
	InputDuration *float64 `json:"input_duration,omitempty"`

	// Text The transcribed text
	Text string `json:"text"`

	// Transcription The transcription of the audio
	Transcription *[]interface{} `json:"transcription"`
}

// StartSessionApiRequestBody defines model for StartSessionApiRequestBody.
type StartSessionApiRequestBody struct {
	// AvatarId The avatar id
	AvatarId string `json:"avatar_id"`

	// IdleTimeout Idle timeout in mins. The default value is 15 minutes if not specified. Setting it to -1 will disable the idle timeout, making the session never auto-terminate due to inactivity.
	IdleTimeout *int64 `json:"idle_timeout,omitempty"`

	// Instruction The instruction prompt for the avatar in the session
	Instruction string `json:"instruction"`

	// LlmModel The LLM model to be used for generating avatar's response
	LlmModel string `json:"llm_model"`

	// Model The interactive model version. The default model used is 'metis-2.5'
	Model *StartSessionApiRequestBodyModel `json:"model,omitempty"`

	// Tools The tools to be used in the session
	Tools *string `json:"tools,omitempty"`

	// UseBeta Use beta interactive model. Beta model is the latest dev model, which is rapidly changed, may have bugs and not suitable for production. Default is false.
	UseBeta *bool `json:"use_beta,omitempty"`

	// VoiceProfileId The voice profile id
	VoiceProfileId string `json:"voice_profile_id"`
}

// StartSessionApiRequestBodyModel The interactive model version. The default model used is 'metis-2.5'
type StartSessionApiRequestBodyModel string

// StartSessionApiResponseBody defines model for StartSessionApiResponseBody.
type StartSessionApiResponseBody struct {
	Data *StartSessionOutput `json:"data,omitempty"`
}

// StartSessionOutput defines model for StartSessionOutput.
type StartSessionOutput struct {
	Session MetisSession `json:"session"`

	// SessionToken The session token for the started session
	SessionToken string `json:"session_token"`
}

// StopSessionOutput defines model for StopSessionOutput.
type StopSessionOutput struct {
	// StoppedSessions The list of stopped session IDs
	StoppedSessions *[]string `json:"stopped_sessions"`
}

// StopSessionsApiRequestBody defines model for StopSessionsApiRequestBody.
type StopSessionsApiRequestBody struct {
	// SessionIds The id of the sessions to be stopped
	SessionIds *[]string `json:"session_ids"`
}

// StopSessionsApiResponseBody defines model for StopSessionsApiResponseBody.
type StopSessionsApiResponseBody struct {
	Data *StopSessionOutput `json:"data,omitempty"`
}

// TTSApiRequestBody defines model for TTSApiRequestBody.
type TTSApiRequestBody struct {
	// ChineseLanguage This param tells the TTS to use the chinese language dialect to generate audio, and only required when generating audio with Mandarin or Cantonese. Currently supports 'mandarin' and 'yue' (i.e. Cantonese) variants.
	ChineseLanguage *TTSApiRequestBodyChineseLanguage `json:"chinese_language,omitempty"`
	Opts            *TTSParams                        `json:"opts,omitempty"`

	// ReturnType Return type of the audio, either 'b64_audio_str' or 'file_url'.
	ReturnType string `json:"return_type"`

	// Text Text to be converted to speech
	Text string `json:"text"`

	// VoiceProfileId Voice profile ID
	VoiceProfileId string `json:"voice_profile_id"`
}

// TTSApiRequestBodyChineseLanguage This param tells the TTS to use the chinese language dialect to generate audio, and only required when generating audio with Mandarin or Cantonese. Currently supports 'mandarin' and 'yue' (i.e. Cantonese) variants.
type TTSApiRequestBodyChineseLanguage string

// TTSApiResponseBody defines model for TTSApiResponseBody.
type TTSApiResponseBody struct {
	Data *TTSOutput `json:"data,omitempty"`
}

// TTSOutput defines model for TTSOutput.
type TTSOutput struct {
	// B64AudioStr The PCM s16 audio data encoded as a base64 string. Only available when the return_type is 'b64_audio_str'.
	B64AudioStr *string `json:"b64_audio_str,omitempty"`

	// FileUrl The URL of the audio file. Only available when the return_type is 'file_url'.
	FileUrl *string `json:"file_url,omitempty"`

	// Id The unique request ID
	Id string `json:"id"`

	// OutputDuration The duration of the output audio in seconds.
	OutputDuration *float64 `json:"output_duration,omitempty"`

	// VoiceProfileId The voice profile ID used for TTS
	VoiceProfileId string `json:"voice_profile_id"`
}

// TTSParams defines model for TTSParams.
type TTSParams struct {
	// FragmentInterval Control the length of pause between sentenses. Default is 0.1.
	FragmentInterval *float32 `json:"fragment_interval,omitempty"`

	// Temperature The temperature for the TTS model, controls the randomness of the output. Default is 1.0.
	Temperature *float32 `json:"temperature,omitempty"`
}

// TerminateApiRequestBody defines model for TerminateApiRequestBody.
type TerminateApiRequestBody struct {
	// InstanceId The id of the instances to be terminated
	InstanceId *[]string `json:"instance_id"`
}

// TerminateApiResponseBody defines model for TerminateApiResponseBody.
type TerminateApiResponseBody struct {
	Data *TerminateInstancesOutput `json:"data,omitempty"`
}

// TerminateInstancesOutput defines model for TerminateInstancesOutput.
type TerminateInstancesOutput struct {
	// TerminatedInstances The list of terminated instance IDs
	TerminatedInstances *[]string `json:"terminated_instances"`
}

// Webhook defines model for Webhook.
type Webhook struct {
	// AuthToken Auth token used to authenticate the webhook via 'Authorization: Bearer' header
	AuthToken *string `json:"auth_token,omitempty"`

	// Url Webhook URL to receive the async task status
	Url string `json:"url"`
}

// CloneVoiceAsyncMultipartBody defines parameters for CloneVoiceAsync.
type CloneVoiceAsyncMultipartBody struct {
	// AnnotationList The annotation file for the voice cloning task
	AnnotationList openapi_types.File   `json:"annotation_list"`
	AudioSamples   []openapi_types.File `json:"audio_samples"`

	// CleanData Specify whether de-noise processing should be performed. Default is False.
	CleanData *bool `json:"clean_data,omitempty"`

	// Description Optional description for the new voice profile.
	Description *string `json:"description,omitempty"`

	// Name The name of the new voice profile to be created. If not provided, a default name will be generated.
	Name *string `json:"name,omitempty"`

	// Webhook Optional webhook url to notify when the task is completed
	Webhook *string `json:"webhook,omitempty"`

	// WebhookAuth Auth token for webhook authentication
	WebhookAuth *string `json:"webhook_auth,omitempty"`
}

// BuildAvatarAsyncJSONRequestBody defines body for BuildAvatarAsync for application/json ContentType.
type BuildAvatarAsyncJSONRequestBody = AsyncBuildApiRequestBody

// GenerateAvatarAsyncJSONRequestBody defines body for GenerateAvatarAsync for application/json ContentType.
type GenerateAvatarAsyncJSONRequestBody = AsyncGenerateAvatarApiRequestBody

// GenerateImageAsyncJSONRequestBody defines body for GenerateImageAsync for application/json ContentType.
type GenerateImageAsyncJSONRequestBody = AsyncGenerateImageApiRequestBody

// GenerateImageJSONRequestBody defines body for GenerateImage for application/json ContentType.
type GenerateImageJSONRequestBody = GenerateImageApiRequestBody

// StartInteractiveSessionJSONRequestBody defines body for StartInteractiveSession for application/json ContentType.
type StartInteractiveSessionJSONRequestBody = StartSessionApiRequestBody

// StopInteractiveSessionsJSONRequestBody defines body for StopInteractiveSessions for application/json ContentType.
type StopInteractiveSessionsJSONRequestBody = StopSessionsApiRequestBody

// ConvertSpeechToTextJSONRequestBody defines body for ConvertSpeechToText for application/json ContentType.
type ConvertSpeechToTextJSONRequestBody = STTApiRequestBody

// ConvertTextToSpeechJSONRequestBody defines body for ConvertTextToSpeech for application/json ContentType.
type ConvertTextToSpeechJSONRequestBody = TTSApiRequestBody

// GenerateAvatarMotionAsyncJSONRequestBody defines body for GenerateAvatarMotionAsync for application/json ContentType.
type GenerateAvatarMotionAsyncJSONRequestBody = AsyncGenerateAvatarMotionApiRequestBody

// GenerateTalkingAvatarAsyncJSONRequestBody defines body for GenerateTalkingAvatarAsync for application/json ContentType.
type GenerateTalkingAvatarAsyncJSONRequestBody = AsyncGenerateTalkingAvatarApiRequestBody

// CloneVoiceAsyncMultipartRequestBody defines body for CloneVoiceAsync for multipart/form-data ContentType.
type CloneVoiceAsyncMultipartRequestBody CloneVoiceAsyncMultipartBody

// Getter for additional properties for AsyncFinetunningWebhookRequestBody. Returns the specified
// element and whether it was found
func (a AsyncFinetunningWebhookRequestBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AsyncFinetunningWebhookRequestBody
func (a *AsyncFinetunningWebhookRequestBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AsyncFinetunningWebhookRequestBody to handle AdditionalProperties
func (a *AsyncFinetunningWebhookRequestBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["delayTime"]; found {
		err = json.Unmarshal(raw, &a.DelayTime)
		if err != nil {
			return fmt.Errorf("error reading 'delayTime': %w", err)
		}
		delete(object, "delayTime")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["executionTime"]; found {
		err = json.Unmarshal(raw, &a.ExecutionTime)
		if err != nil {
			return fmt.Errorf("error reading 'executionTime': %w", err)
		}
		delete(object, "executionTime")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["output"]; found {
		err = json.Unmarshal(raw, &a.Output)
		if err != nil {
			return fmt.Errorf("error reading 'output': %w", err)
		}
		delete(object, "output")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AsyncFinetunningWebhookRequestBody to handle AdditionalProperties
func (a AsyncFinetunningWebhookRequestBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["delayTime"], err = json.Marshal(a.DelayTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'delayTime': %w", err)
	}

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	object["executionTime"], err = json.Marshal(a.ExecutionTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'executionTime': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.Output != nil {
		object["output"], err = json.Marshal(a.Output)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'output': %w", err)
		}
	}

	object["status"], err = json.Marshal(a.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AsyncGenerateAvatarWebhookRequestBody. Returns the specified
// element and whether it was found
func (a AsyncGenerateAvatarWebhookRequestBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AsyncGenerateAvatarWebhookRequestBody
func (a *AsyncGenerateAvatarWebhookRequestBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AsyncGenerateAvatarWebhookRequestBody to handle AdditionalProperties
func (a *AsyncGenerateAvatarWebhookRequestBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["delayTime"]; found {
		err = json.Unmarshal(raw, &a.DelayTime)
		if err != nil {
			return fmt.Errorf("error reading 'delayTime': %w", err)
		}
		delete(object, "delayTime")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["executionTime"]; found {
		err = json.Unmarshal(raw, &a.ExecutionTime)
		if err != nil {
			return fmt.Errorf("error reading 'executionTime': %w", err)
		}
		delete(object, "executionTime")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["output"]; found {
		err = json.Unmarshal(raw, &a.Output)
		if err != nil {
			return fmt.Errorf("error reading 'output': %w", err)
		}
		delete(object, "output")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AsyncGenerateAvatarWebhookRequestBody to handle AdditionalProperties
func (a AsyncGenerateAvatarWebhookRequestBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["delayTime"], err = json.Marshal(a.DelayTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'delayTime': %w", err)
	}

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	object["executionTime"], err = json.Marshal(a.ExecutionTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'executionTime': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.Output != nil {
		object["output"], err = json.Marshal(a.Output)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'output': %w", err)
		}
	}

	object["status"], err = json.Marshal(a.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GenerateAvatarMotionWebhookRequestBody. Returns the specified
// element and whether it was found
func (a GenerateAvatarMotionWebhookRequestBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GenerateAvatarMotionWebhookRequestBody
func (a *GenerateAvatarMotionWebhookRequestBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GenerateAvatarMotionWebhookRequestBody to handle AdditionalProperties
func (a *GenerateAvatarMotionWebhookRequestBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["delayTime"]; found {
		err = json.Unmarshal(raw, &a.DelayTime)
		if err != nil {
			return fmt.Errorf("error reading 'delayTime': %w", err)
		}
		delete(object, "delayTime")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["executionTime"]; found {
		err = json.Unmarshal(raw, &a.ExecutionTime)
		if err != nil {
			return fmt.Errorf("error reading 'executionTime': %w", err)
		}
		delete(object, "executionTime")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["output"]; found {
		err = json.Unmarshal(raw, &a.Output)
		if err != nil {
			return fmt.Errorf("error reading 'output': %w", err)
		}
		delete(object, "output")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GenerateAvatarMotionWebhookRequestBody to handle AdditionalProperties
func (a GenerateAvatarMotionWebhookRequestBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["delayTime"], err = json.Marshal(a.DelayTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'delayTime': %w", err)
	}

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	object["executionTime"], err = json.Marshal(a.ExecutionTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'executionTime': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.Output != nil {
		object["output"], err = json.Marshal(a.Output)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'output': %w", err)
		}
	}

	object["status"], err = json.Marshal(a.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GenerateTalkingAvatarWebhookRequestBody. Returns the specified
// element and whether it was found
func (a GenerateTalkingAvatarWebhookRequestBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GenerateTalkingAvatarWebhookRequestBody
func (a *GenerateTalkingAvatarWebhookRequestBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GenerateTalkingAvatarWebhookRequestBody to handle AdditionalProperties
func (a *GenerateTalkingAvatarWebhookRequestBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["delayTime"]; found {
		err = json.Unmarshal(raw, &a.DelayTime)
		if err != nil {
			return fmt.Errorf("error reading 'delayTime': %w", err)
		}
		delete(object, "delayTime")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["executionTime"]; found {
		err = json.Unmarshal(raw, &a.ExecutionTime)
		if err != nil {
			return fmt.Errorf("error reading 'executionTime': %w", err)
		}
		delete(object, "executionTime")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["output"]; found {
		err = json.Unmarshal(raw, &a.Output)
		if err != nil {
			return fmt.Errorf("error reading 'output': %w", err)
		}
		delete(object, "output")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GenerateTalkingAvatarWebhookRequestBody to handle AdditionalProperties
func (a GenerateTalkingAvatarWebhookRequestBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["delayTime"], err = json.Marshal(a.DelayTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'delayTime': %w", err)
	}

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	object["executionTime"], err = json.Marshal(a.ExecutionTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'executionTime': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.Output != nil {
		object["output"], err = json.Marshal(a.Output)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'output': %w", err)
		}
	}

	object["status"], err = json.Marshal(a.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// BuildAvatarAsyncWithBody request with any body
	BuildAvatarAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BuildAvatarAsync(ctx context.Context, body BuildAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateAvatarAsyncWithBody request with any body
	GenerateAvatarAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateAvatarAsync(ctx context.Context, body GenerateAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvatarGenerationStatus request
	GetAvatarGenerationStatus(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserAvatarList request
	GetUserAvatarList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAvatar request
	DeleteAvatar(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvatarById request
	GetAvatarById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateImageAsyncWithBody request with any body
	GenerateImageAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateImageAsync(ctx context.Context, body GenerateImageAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImageGenerationStatus request
	GetImageGenerationStatus(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateImageWithBody request with any body
	GenerateImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateImage(ctx context.Context, body GenerateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInteractiveSessions request
	ListInteractiveSessions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessionProfile request
	GetSessionProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartInteractiveSessionWithBody request with any body
	StartInteractiveSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartInteractiveSession(ctx context.Context, body StartInteractiveSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopInteractiveSessionsWithBody request with any body
	StopInteractiveSessionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopInteractiveSessions(ctx context.Context, body StopInteractiveSessionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertSpeechToTextWithBody request with any body
	ConvertSpeechToTextWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConvertSpeechToText(ctx context.Context, body ConvertSpeechToTextJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertTextToSpeechWithBody request with any body
	ConvertTextToSpeechWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConvertTextToSpeech(ctx context.Context, body ConvertTextToSpeechJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateAvatarMotionAsyncWithBody request with any body
	GenerateAvatarMotionAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateAvatarMotionAsync(ctx context.Context, body GenerateAvatarMotionAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvatarMotionGenerationStatus request
	GetAvatarMotionGenerationStatus(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTalkingAvatarAsyncWithBody request with any body
	GenerateTalkingAvatarAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateTalkingAvatarAsync(ctx context.Context, body GenerateTalkingAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTalkingAvatarGenerationStatus request
	GetTalkingAvatarGenerationStatus(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloneVoiceAsyncWithBody request with any body
	CloneVoiceAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoiceCloningStatus request
	GetVoiceCloningStatus(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPremadeVoiceProfiles request
	GetPremadeVoiceProfiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserVoiceProfiles request
	GetUserVoiceProfiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVoiceProfile request
	DeleteVoiceProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoiceProfile request
	GetVoiceProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) BuildAvatarAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildAvatarAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BuildAvatarAsync(ctx context.Context, body BuildAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBuildAvatarAsyncRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateAvatarAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateAvatarAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateAvatarAsync(ctx context.Context, body GenerateAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateAvatarAsyncRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvatarGenerationStatus(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvatarGenerationStatusRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserAvatarList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserAvatarListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAvatar(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAvatarRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvatarById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvatarByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateImageAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateImageAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateImageAsync(ctx context.Context, body GenerateImageAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateImageAsyncRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImageGenerationStatus(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImageGenerationStatusRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateImage(ctx context.Context, body GenerateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateImageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInteractiveSessions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInteractiveSessionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionProfileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartInteractiveSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartInteractiveSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartInteractiveSession(ctx context.Context, body StartInteractiveSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartInteractiveSessionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopInteractiveSessionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopInteractiveSessionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopInteractiveSessions(ctx context.Context, body StopInteractiveSessionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopInteractiveSessionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertSpeechToTextWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertSpeechToTextRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertSpeechToText(ctx context.Context, body ConvertSpeechToTextJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertSpeechToTextRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertTextToSpeechWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertTextToSpeechRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertTextToSpeech(ctx context.Context, body ConvertTextToSpeechJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertTextToSpeechRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateAvatarMotionAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateAvatarMotionAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateAvatarMotionAsync(ctx context.Context, body GenerateAvatarMotionAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateAvatarMotionAsyncRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvatarMotionGenerationStatus(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvatarMotionGenerationStatusRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTalkingAvatarAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTalkingAvatarAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTalkingAvatarAsync(ctx context.Context, body GenerateTalkingAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTalkingAvatarAsyncRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTalkingAvatarGenerationStatus(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTalkingAvatarGenerationStatusRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneVoiceAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneVoiceAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoiceCloningStatus(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoiceCloningStatusRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPremadeVoiceProfiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPremadeVoiceProfilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserVoiceProfiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserVoiceProfilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVoiceProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVoiceProfileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoiceProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoiceProfileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewBuildAvatarAsyncRequest calls the generic BuildAvatarAsync builder with application/json body
func NewBuildAvatarAsyncRequest(server string, body BuildAvatarAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildAvatarAsyncRequestWithBody(server, "application/json", bodyReader)
}

// NewBuildAvatarAsyncRequestWithBody generates requests for BuildAvatarAsync with any type of body
func NewBuildAvatarAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/avatar/async_build")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateAvatarAsyncRequest calls the generic GenerateAvatarAsync builder with application/json body
func NewGenerateAvatarAsyncRequest(server string, body GenerateAvatarAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateAvatarAsyncRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateAvatarAsyncRequestWithBody generates requests for GenerateAvatarAsync with any type of body
func NewGenerateAvatarAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/avatar/async_generate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAvatarGenerationStatusRequest generates requests for GetAvatarGenerationStatus
func NewGetAvatarGenerationStatusRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/avatar/async_generate/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserAvatarListRequest generates requests for GetUserAvatarList
func NewGetUserAvatarListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/avatar/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAvatarRequest generates requests for DeleteAvatar
func NewDeleteAvatarRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/avatar/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAvatarByIdRequest generates requests for GetAvatarById
func NewGetAvatarByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/avatar/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateImageAsyncRequest calls the generic GenerateImageAsync builder with application/json body
func NewGenerateImageAsyncRequest(server string, body GenerateImageAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateImageAsyncRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateImageAsyncRequestWithBody generates requests for GenerateImageAsync with any type of body
func NewGenerateImageAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/image/async_generate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetImageGenerationStatusRequest generates requests for GetImageGenerationStatus
func NewGetImageGenerationStatusRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/image/async_generate/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateImageRequest calls the generic GenerateImage builder with application/json body
func NewGenerateImageRequest(server string, body GenerateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateImageRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateImageRequestWithBody generates requests for GenerateImage with any type of body
func NewGenerateImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/image/generate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListInteractiveSessionsRequest generates requests for ListInteractiveSessions
func NewListInteractiveSessionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/interactive/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSessionProfileRequest generates requests for GetSessionProfile
func NewGetSessionProfileRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/interactive/session/%s/profile", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartInteractiveSessionRequest calls the generic StartInteractiveSession builder with application/json body
func NewStartInteractiveSessionRequest(server string, body StartInteractiveSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartInteractiveSessionRequestWithBody(server, "application/json", bodyReader)
}

// NewStartInteractiveSessionRequestWithBody generates requests for StartInteractiveSession with any type of body
func NewStartInteractiveSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/interactive/start_session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStopInteractiveSessionsRequest calls the generic StopInteractiveSessions builder with application/json body
func NewStopInteractiveSessionsRequest(server string, body StopInteractiveSessionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopInteractiveSessionsRequestWithBody(server, "application/json", bodyReader)
}

// NewStopInteractiveSessionsRequestWithBody generates requests for StopInteractiveSessions with any type of body
func NewStopInteractiveSessionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/interactive/stop_sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConvertSpeechToTextRequest calls the generic ConvertSpeechToText builder with application/json body
func NewConvertSpeechToTextRequest(server string, body ConvertSpeechToTextJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConvertSpeechToTextRequestWithBody(server, "application/json", bodyReader)
}

// NewConvertSpeechToTextRequestWithBody generates requests for ConvertSpeechToText with any type of body
func NewConvertSpeechToTextRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/speech/stt")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConvertTextToSpeechRequest calls the generic ConvertTextToSpeech builder with application/json body
func NewConvertTextToSpeechRequest(server string, body ConvertTextToSpeechJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConvertTextToSpeechRequestWithBody(server, "application/json", bodyReader)
}

// NewConvertTextToSpeechRequestWithBody generates requests for ConvertTextToSpeech with any type of body
func NewConvertTextToSpeechRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/speech/tts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateAvatarMotionAsyncRequest calls the generic GenerateAvatarMotionAsync builder with application/json body
func NewGenerateAvatarMotionAsyncRequest(server string, body GenerateAvatarMotionAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateAvatarMotionAsyncRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateAvatarMotionAsyncRequestWithBody generates requests for GenerateAvatarMotionAsync with any type of body
func NewGenerateAvatarMotionAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/video/async_generate_avatar_motion")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAvatarMotionGenerationStatusRequest generates requests for GetAvatarMotionGenerationStatus
func NewGetAvatarMotionGenerationStatusRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/video/async_generate_avatar_motion/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateTalkingAvatarAsyncRequest calls the generic GenerateTalkingAvatarAsync builder with application/json body
func NewGenerateTalkingAvatarAsyncRequest(server string, body GenerateTalkingAvatarAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTalkingAvatarAsyncRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateTalkingAvatarAsyncRequestWithBody generates requests for GenerateTalkingAvatarAsync with any type of body
func NewGenerateTalkingAvatarAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/video/async_generate_talking_avatar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTalkingAvatarGenerationStatusRequest generates requests for GetTalkingAvatarGenerationStatus
func NewGetTalkingAvatarGenerationStatusRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/video/async_generate_talking_avatar/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCloneVoiceAsyncRequestWithBody generates requests for CloneVoiceAsync with any type of body
func NewCloneVoiceAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/voice/clone")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVoiceCloningStatusRequest generates requests for GetVoiceCloningStatus
func NewGetVoiceCloningStatusRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/voice/clone/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPremadeVoiceProfilesRequest generates requests for GetPremadeVoiceProfiles
func NewGetPremadeVoiceProfilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/voice/premade_profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserVoiceProfilesRequest generates requests for GetUserVoiceProfiles
func NewGetUserVoiceProfilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/voice/profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVoiceProfileRequest generates requests for DeleteVoiceProfile
func NewDeleteVoiceProfileRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/voice/profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVoiceProfileRequest generates requests for GetVoiceProfile
func NewGetVoiceProfileRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/voice/profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// BuildAvatarAsyncWithBodyWithResponse request with any body
	BuildAvatarAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildAvatarAsyncResponse, error)

	BuildAvatarAsyncWithResponse(ctx context.Context, body BuildAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildAvatarAsyncResponse, error)

	// GenerateAvatarAsyncWithBodyWithResponse request with any body
	GenerateAvatarAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateAvatarAsyncResponse, error)

	GenerateAvatarAsyncWithResponse(ctx context.Context, body GenerateAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateAvatarAsyncResponse, error)

	// GetAvatarGenerationStatusWithResponse request
	GetAvatarGenerationStatusWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetAvatarGenerationStatusResponse, error)

	// GetUserAvatarListWithResponse request
	GetUserAvatarListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserAvatarListResponse, error)

	// DeleteAvatarWithResponse request
	DeleteAvatarWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAvatarResponse, error)

	// GetAvatarByIdWithResponse request
	GetAvatarByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAvatarByIdResponse, error)

	// GenerateImageAsyncWithBodyWithResponse request with any body
	GenerateImageAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateImageAsyncResponse, error)

	GenerateImageAsyncWithResponse(ctx context.Context, body GenerateImageAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateImageAsyncResponse, error)

	// GetImageGenerationStatusWithResponse request
	GetImageGenerationStatusWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetImageGenerationStatusResponse, error)

	// GenerateImageWithBodyWithResponse request with any body
	GenerateImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateImageResponse, error)

	GenerateImageWithResponse(ctx context.Context, body GenerateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateImageResponse, error)

	// ListInteractiveSessionsWithResponse request
	ListInteractiveSessionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListInteractiveSessionsResponse, error)

	// GetSessionProfileWithResponse request
	GetSessionProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSessionProfileResponse, error)

	// StartInteractiveSessionWithBodyWithResponse request with any body
	StartInteractiveSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartInteractiveSessionResponse, error)

	StartInteractiveSessionWithResponse(ctx context.Context, body StartInteractiveSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*StartInteractiveSessionResponse, error)

	// StopInteractiveSessionsWithBodyWithResponse request with any body
	StopInteractiveSessionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopInteractiveSessionsResponse, error)

	StopInteractiveSessionsWithResponse(ctx context.Context, body StopInteractiveSessionsJSONRequestBody, reqEditors ...RequestEditorFn) (*StopInteractiveSessionsResponse, error)

	// ConvertSpeechToTextWithBodyWithResponse request with any body
	ConvertSpeechToTextWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertSpeechToTextResponse, error)

	ConvertSpeechToTextWithResponse(ctx context.Context, body ConvertSpeechToTextJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertSpeechToTextResponse, error)

	// ConvertTextToSpeechWithBodyWithResponse request with any body
	ConvertTextToSpeechWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertTextToSpeechResponse, error)

	ConvertTextToSpeechWithResponse(ctx context.Context, body ConvertTextToSpeechJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertTextToSpeechResponse, error)

	// GenerateAvatarMotionAsyncWithBodyWithResponse request with any body
	GenerateAvatarMotionAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateAvatarMotionAsyncResponse, error)

	GenerateAvatarMotionAsyncWithResponse(ctx context.Context, body GenerateAvatarMotionAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateAvatarMotionAsyncResponse, error)

	// GetAvatarMotionGenerationStatusWithResponse request
	GetAvatarMotionGenerationStatusWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetAvatarMotionGenerationStatusResponse, error)

	// GenerateTalkingAvatarAsyncWithBodyWithResponse request with any body
	GenerateTalkingAvatarAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTalkingAvatarAsyncResponse, error)

	GenerateTalkingAvatarAsyncWithResponse(ctx context.Context, body GenerateTalkingAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTalkingAvatarAsyncResponse, error)

	// GetTalkingAvatarGenerationStatusWithResponse request
	GetTalkingAvatarGenerationStatusWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetTalkingAvatarGenerationStatusResponse, error)

	// CloneVoiceAsyncWithBodyWithResponse request with any body
	CloneVoiceAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneVoiceAsyncResponse, error)

	// GetVoiceCloningStatusWithResponse request
	GetVoiceCloningStatusWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetVoiceCloningStatusResponse, error)

	// GetPremadeVoiceProfilesWithResponse request
	GetPremadeVoiceProfilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPremadeVoiceProfilesResponse, error)

	// GetUserVoiceProfilesWithResponse request
	GetUserVoiceProfilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserVoiceProfilesResponse, error)

	// DeleteVoiceProfileWithResponse request
	DeleteVoiceProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVoiceProfileResponse, error)

	// GetVoiceProfileWithResponse request
	GetVoiceProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVoiceProfileResponse, error)
}

type BuildAvatarAsyncResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *AsyncBuildApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r BuildAvatarAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildAvatarAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateAvatarAsyncResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *AsyncGenerateAvatarApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GenerateAvatarAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateAvatarAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvatarGenerationStatusResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *GenerateAvatarStatusApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetAvatarGenerationStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvatarGenerationStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserAvatarListResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *GetUserAvatarListApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetUserAvatarListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserAvatarListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAvatarResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r DeleteAvatarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAvatarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvatarByIdResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *GetAvatarApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetAvatarByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvatarByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateImageAsyncResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *AsyncGenerateImageApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GenerateImageAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateImageAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImageGenerationStatusResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *GenerateImageStatusApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetImageGenerationStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImageGenerationStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateImageResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *GenerateImageApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GenerateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInteractiveSessionsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *ListSessionsApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r ListInteractiveSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInteractiveSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionProfileResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *GetSessionProfileApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetSessionProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartInteractiveSessionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *StartSessionApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r StartInteractiveSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartInteractiveSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopInteractiveSessionsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *StopSessionsApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r StopInteractiveSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopInteractiveSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertSpeechToTextResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *STTApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r ConvertSpeechToTextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertSpeechToTextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertTextToSpeechResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *TTSApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r ConvertTextToSpeechResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertTextToSpeechResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateAvatarMotionAsyncResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *AsyncGenerateAvatarMotionApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GenerateAvatarMotionAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateAvatarMotionAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvatarMotionGenerationStatusResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *GenerateAvatarMotionStatusApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetAvatarMotionGenerationStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvatarMotionGenerationStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTalkingAvatarAsyncResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *AsyncGenerateTalkingAvatarApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GenerateTalkingAvatarAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTalkingAvatarAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTalkingAvatarGenerationStatusResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *GenerateTalkingAvatarStatusApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetTalkingAvatarGenerationStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTalkingAvatarGenerationStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloneVoiceAsyncResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *AsyncFinetuningApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r CloneVoiceAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloneVoiceAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoiceCloningStatusResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *FinetuningStatusApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetVoiceCloningStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoiceCloningStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPremadeVoiceProfilesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *GetPremadeProfilesApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetPremadeVoiceProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPremadeVoiceProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserVoiceProfilesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *GetVoiceProfilesApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetUserVoiceProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserVoiceProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVoiceProfileResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *DeleteVoiceProfileApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r DeleteVoiceProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVoiceProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoiceProfileResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *GetVoiceProfileApiResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetVoiceProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoiceProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// BuildAvatarAsyncWithBodyWithResponse request with arbitrary body returning *BuildAvatarAsyncResponse
func (c *ClientWithResponses) BuildAvatarAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BuildAvatarAsyncResponse, error) {
	rsp, err := c.BuildAvatarAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildAvatarAsyncResponse(rsp)
}

func (c *ClientWithResponses) BuildAvatarAsyncWithResponse(ctx context.Context, body BuildAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*BuildAvatarAsyncResponse, error) {
	rsp, err := c.BuildAvatarAsync(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBuildAvatarAsyncResponse(rsp)
}

// GenerateAvatarAsyncWithBodyWithResponse request with arbitrary body returning *GenerateAvatarAsyncResponse
func (c *ClientWithResponses) GenerateAvatarAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateAvatarAsyncResponse, error) {
	rsp, err := c.GenerateAvatarAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateAvatarAsyncResponse(rsp)
}

func (c *ClientWithResponses) GenerateAvatarAsyncWithResponse(ctx context.Context, body GenerateAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateAvatarAsyncResponse, error) {
	rsp, err := c.GenerateAvatarAsync(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateAvatarAsyncResponse(rsp)
}

// GetAvatarGenerationStatusWithResponse request returning *GetAvatarGenerationStatusResponse
func (c *ClientWithResponses) GetAvatarGenerationStatusWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetAvatarGenerationStatusResponse, error) {
	rsp, err := c.GetAvatarGenerationStatus(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvatarGenerationStatusResponse(rsp)
}

// GetUserAvatarListWithResponse request returning *GetUserAvatarListResponse
func (c *ClientWithResponses) GetUserAvatarListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserAvatarListResponse, error) {
	rsp, err := c.GetUserAvatarList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserAvatarListResponse(rsp)
}

// DeleteAvatarWithResponse request returning *DeleteAvatarResponse
func (c *ClientWithResponses) DeleteAvatarWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAvatarResponse, error) {
	rsp, err := c.DeleteAvatar(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAvatarResponse(rsp)
}

// GetAvatarByIdWithResponse request returning *GetAvatarByIdResponse
func (c *ClientWithResponses) GetAvatarByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAvatarByIdResponse, error) {
	rsp, err := c.GetAvatarById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvatarByIdResponse(rsp)
}

// GenerateImageAsyncWithBodyWithResponse request with arbitrary body returning *GenerateImageAsyncResponse
func (c *ClientWithResponses) GenerateImageAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateImageAsyncResponse, error) {
	rsp, err := c.GenerateImageAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateImageAsyncResponse(rsp)
}

func (c *ClientWithResponses) GenerateImageAsyncWithResponse(ctx context.Context, body GenerateImageAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateImageAsyncResponse, error) {
	rsp, err := c.GenerateImageAsync(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateImageAsyncResponse(rsp)
}

// GetImageGenerationStatusWithResponse request returning *GetImageGenerationStatusResponse
func (c *ClientWithResponses) GetImageGenerationStatusWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetImageGenerationStatusResponse, error) {
	rsp, err := c.GetImageGenerationStatus(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImageGenerationStatusResponse(rsp)
}

// GenerateImageWithBodyWithResponse request with arbitrary body returning *GenerateImageResponse
func (c *ClientWithResponses) GenerateImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateImageResponse, error) {
	rsp, err := c.GenerateImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateImageResponse(rsp)
}

func (c *ClientWithResponses) GenerateImageWithResponse(ctx context.Context, body GenerateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateImageResponse, error) {
	rsp, err := c.GenerateImage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateImageResponse(rsp)
}

// ListInteractiveSessionsWithResponse request returning *ListInteractiveSessionsResponse
func (c *ClientWithResponses) ListInteractiveSessionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListInteractiveSessionsResponse, error) {
	rsp, err := c.ListInteractiveSessions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInteractiveSessionsResponse(rsp)
}

// GetSessionProfileWithResponse request returning *GetSessionProfileResponse
func (c *ClientWithResponses) GetSessionProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSessionProfileResponse, error) {
	rsp, err := c.GetSessionProfile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionProfileResponse(rsp)
}

// StartInteractiveSessionWithBodyWithResponse request with arbitrary body returning *StartInteractiveSessionResponse
func (c *ClientWithResponses) StartInteractiveSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartInteractiveSessionResponse, error) {
	rsp, err := c.StartInteractiveSessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartInteractiveSessionResponse(rsp)
}

func (c *ClientWithResponses) StartInteractiveSessionWithResponse(ctx context.Context, body StartInteractiveSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*StartInteractiveSessionResponse, error) {
	rsp, err := c.StartInteractiveSession(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartInteractiveSessionResponse(rsp)
}

// StopInteractiveSessionsWithBodyWithResponse request with arbitrary body returning *StopInteractiveSessionsResponse
func (c *ClientWithResponses) StopInteractiveSessionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopInteractiveSessionsResponse, error) {
	rsp, err := c.StopInteractiveSessionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopInteractiveSessionsResponse(rsp)
}

func (c *ClientWithResponses) StopInteractiveSessionsWithResponse(ctx context.Context, body StopInteractiveSessionsJSONRequestBody, reqEditors ...RequestEditorFn) (*StopInteractiveSessionsResponse, error) {
	rsp, err := c.StopInteractiveSessions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopInteractiveSessionsResponse(rsp)
}

// ConvertSpeechToTextWithBodyWithResponse request with arbitrary body returning *ConvertSpeechToTextResponse
func (c *ClientWithResponses) ConvertSpeechToTextWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertSpeechToTextResponse, error) {
	rsp, err := c.ConvertSpeechToTextWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertSpeechToTextResponse(rsp)
}

func (c *ClientWithResponses) ConvertSpeechToTextWithResponse(ctx context.Context, body ConvertSpeechToTextJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertSpeechToTextResponse, error) {
	rsp, err := c.ConvertSpeechToText(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertSpeechToTextResponse(rsp)
}

// ConvertTextToSpeechWithBodyWithResponse request with arbitrary body returning *ConvertTextToSpeechResponse
func (c *ClientWithResponses) ConvertTextToSpeechWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertTextToSpeechResponse, error) {
	rsp, err := c.ConvertTextToSpeechWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertTextToSpeechResponse(rsp)
}

func (c *ClientWithResponses) ConvertTextToSpeechWithResponse(ctx context.Context, body ConvertTextToSpeechJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertTextToSpeechResponse, error) {
	rsp, err := c.ConvertTextToSpeech(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertTextToSpeechResponse(rsp)
}

// GenerateAvatarMotionAsyncWithBodyWithResponse request with arbitrary body returning *GenerateAvatarMotionAsyncResponse
func (c *ClientWithResponses) GenerateAvatarMotionAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateAvatarMotionAsyncResponse, error) {
	rsp, err := c.GenerateAvatarMotionAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateAvatarMotionAsyncResponse(rsp)
}

func (c *ClientWithResponses) GenerateAvatarMotionAsyncWithResponse(ctx context.Context, body GenerateAvatarMotionAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateAvatarMotionAsyncResponse, error) {
	rsp, err := c.GenerateAvatarMotionAsync(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateAvatarMotionAsyncResponse(rsp)
}

// GetAvatarMotionGenerationStatusWithResponse request returning *GetAvatarMotionGenerationStatusResponse
func (c *ClientWithResponses) GetAvatarMotionGenerationStatusWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetAvatarMotionGenerationStatusResponse, error) {
	rsp, err := c.GetAvatarMotionGenerationStatus(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvatarMotionGenerationStatusResponse(rsp)
}

// GenerateTalkingAvatarAsyncWithBodyWithResponse request with arbitrary body returning *GenerateTalkingAvatarAsyncResponse
func (c *ClientWithResponses) GenerateTalkingAvatarAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTalkingAvatarAsyncResponse, error) {
	rsp, err := c.GenerateTalkingAvatarAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTalkingAvatarAsyncResponse(rsp)
}

func (c *ClientWithResponses) GenerateTalkingAvatarAsyncWithResponse(ctx context.Context, body GenerateTalkingAvatarAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTalkingAvatarAsyncResponse, error) {
	rsp, err := c.GenerateTalkingAvatarAsync(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTalkingAvatarAsyncResponse(rsp)
}

// GetTalkingAvatarGenerationStatusWithResponse request returning *GetTalkingAvatarGenerationStatusResponse
func (c *ClientWithResponses) GetTalkingAvatarGenerationStatusWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetTalkingAvatarGenerationStatusResponse, error) {
	rsp, err := c.GetTalkingAvatarGenerationStatus(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTalkingAvatarGenerationStatusResponse(rsp)
}

// CloneVoiceAsyncWithBodyWithResponse request with arbitrary body returning *CloneVoiceAsyncResponse
func (c *ClientWithResponses) CloneVoiceAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneVoiceAsyncResponse, error) {
	rsp, err := c.CloneVoiceAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneVoiceAsyncResponse(rsp)
}

// GetVoiceCloningStatusWithResponse request returning *GetVoiceCloningStatusResponse
func (c *ClientWithResponses) GetVoiceCloningStatusWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetVoiceCloningStatusResponse, error) {
	rsp, err := c.GetVoiceCloningStatus(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoiceCloningStatusResponse(rsp)
}

// GetPremadeVoiceProfilesWithResponse request returning *GetPremadeVoiceProfilesResponse
func (c *ClientWithResponses) GetPremadeVoiceProfilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPremadeVoiceProfilesResponse, error) {
	rsp, err := c.GetPremadeVoiceProfiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPremadeVoiceProfilesResponse(rsp)
}

// GetUserVoiceProfilesWithResponse request returning *GetUserVoiceProfilesResponse
func (c *ClientWithResponses) GetUserVoiceProfilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserVoiceProfilesResponse, error) {
	rsp, err := c.GetUserVoiceProfiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserVoiceProfilesResponse(rsp)
}

// DeleteVoiceProfileWithResponse request returning *DeleteVoiceProfileResponse
func (c *ClientWithResponses) DeleteVoiceProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteVoiceProfileResponse, error) {
	rsp, err := c.DeleteVoiceProfile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVoiceProfileResponse(rsp)
}

// GetVoiceProfileWithResponse request returning *GetVoiceProfileResponse
func (c *ClientWithResponses) GetVoiceProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVoiceProfileResponse, error) {
	rsp, err := c.GetVoiceProfile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoiceProfileResponse(rsp)
}

// ParseBuildAvatarAsyncResponse parses an HTTP response from a BuildAvatarAsyncWithResponse call
func ParseBuildAvatarAsyncResponse(rsp *http.Response) (*BuildAvatarAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BuildAvatarAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AsyncBuildApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGenerateAvatarAsyncResponse parses an HTTP response from a GenerateAvatarAsyncWithResponse call
func ParseGenerateAvatarAsyncResponse(rsp *http.Response) (*GenerateAvatarAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateAvatarAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AsyncGenerateAvatarApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetAvatarGenerationStatusResponse parses an HTTP response from a GetAvatarGenerationStatusWithResponse call
func ParseGetAvatarGenerationStatusResponse(rsp *http.Response) (*GetAvatarGenerationStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvatarGenerationStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GenerateAvatarStatusApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserAvatarListResponse parses an HTTP response from a GetUserAvatarListWithResponse call
func ParseGetUserAvatarListResponse(rsp *http.Response) (*GetUserAvatarListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserAvatarListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserAvatarListApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAvatarResponse parses an HTTP response from a DeleteAvatarWithResponse call
func ParseDeleteAvatarResponse(rsp *http.Response) (*DeleteAvatarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAvatarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetAvatarByIdResponse parses an HTTP response from a GetAvatarByIdWithResponse call
func ParseGetAvatarByIdResponse(rsp *http.Response) (*GetAvatarByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvatarByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAvatarApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGenerateImageAsyncResponse parses an HTTP response from a GenerateImageAsyncWithResponse call
func ParseGenerateImageAsyncResponse(rsp *http.Response) (*GenerateImageAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateImageAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AsyncGenerateImageApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetImageGenerationStatusResponse parses an HTTP response from a GetImageGenerationStatusWithResponse call
func ParseGetImageGenerationStatusResponse(rsp *http.Response) (*GetImageGenerationStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImageGenerationStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GenerateImageStatusApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGenerateImageResponse parses an HTTP response from a GenerateImageWithResponse call
func ParseGenerateImageResponse(rsp *http.Response) (*GenerateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GenerateImageApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListInteractiveSessionsResponse parses an HTTP response from a ListInteractiveSessionsWithResponse call
func ParseListInteractiveSessionsResponse(rsp *http.Response) (*ListInteractiveSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInteractiveSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSessionsApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetSessionProfileResponse parses an HTTP response from a GetSessionProfileWithResponse call
func ParseGetSessionProfileResponse(rsp *http.Response) (*GetSessionProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSessionProfileApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseStartInteractiveSessionResponse parses an HTTP response from a StartInteractiveSessionWithResponse call
func ParseStartInteractiveSessionResponse(rsp *http.Response) (*StartInteractiveSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartInteractiveSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartSessionApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseStopInteractiveSessionsResponse parses an HTTP response from a StopInteractiveSessionsWithResponse call
func ParseStopInteractiveSessionsResponse(rsp *http.Response) (*StopInteractiveSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopInteractiveSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StopSessionsApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseConvertSpeechToTextResponse parses an HTTP response from a ConvertSpeechToTextWithResponse call
func ParseConvertSpeechToTextResponse(rsp *http.Response) (*ConvertSpeechToTextResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertSpeechToTextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest STTApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseConvertTextToSpeechResponse parses an HTTP response from a ConvertTextToSpeechWithResponse call
func ParseConvertTextToSpeechResponse(rsp *http.Response) (*ConvertTextToSpeechResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertTextToSpeechResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TTSApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGenerateAvatarMotionAsyncResponse parses an HTTP response from a GenerateAvatarMotionAsyncWithResponse call
func ParseGenerateAvatarMotionAsyncResponse(rsp *http.Response) (*GenerateAvatarMotionAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateAvatarMotionAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AsyncGenerateAvatarMotionApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetAvatarMotionGenerationStatusResponse parses an HTTP response from a GetAvatarMotionGenerationStatusWithResponse call
func ParseGetAvatarMotionGenerationStatusResponse(rsp *http.Response) (*GetAvatarMotionGenerationStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvatarMotionGenerationStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GenerateAvatarMotionStatusApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGenerateTalkingAvatarAsyncResponse parses an HTTP response from a GenerateTalkingAvatarAsyncWithResponse call
func ParseGenerateTalkingAvatarAsyncResponse(rsp *http.Response) (*GenerateTalkingAvatarAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTalkingAvatarAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AsyncGenerateTalkingAvatarApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetTalkingAvatarGenerationStatusResponse parses an HTTP response from a GetTalkingAvatarGenerationStatusWithResponse call
func ParseGetTalkingAvatarGenerationStatusResponse(rsp *http.Response) (*GetTalkingAvatarGenerationStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTalkingAvatarGenerationStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GenerateTalkingAvatarStatusApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCloneVoiceAsyncResponse parses an HTTP response from a CloneVoiceAsyncWithResponse call
func ParseCloneVoiceAsyncResponse(rsp *http.Response) (*CloneVoiceAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloneVoiceAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AsyncFinetuningApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetVoiceCloningStatusResponse parses an HTTP response from a GetVoiceCloningStatusWithResponse call
func ParseGetVoiceCloningStatusResponse(rsp *http.Response) (*GetVoiceCloningStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoiceCloningStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FinetuningStatusApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetPremadeVoiceProfilesResponse parses an HTTP response from a GetPremadeVoiceProfilesWithResponse call
func ParseGetPremadeVoiceProfilesResponse(rsp *http.Response) (*GetPremadeVoiceProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPremadeVoiceProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPremadeProfilesApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserVoiceProfilesResponse parses an HTTP response from a GetUserVoiceProfilesWithResponse call
func ParseGetUserVoiceProfilesResponse(rsp *http.Response) (*GetUserVoiceProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserVoiceProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetVoiceProfilesApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVoiceProfileResponse parses an HTTP response from a DeleteVoiceProfileWithResponse call
func ParseDeleteVoiceProfileResponse(rsp *http.Response) (*DeleteVoiceProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVoiceProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteVoiceProfileApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetVoiceProfileResponse parses an HTTP response from a GetVoiceProfileWithResponse call
func ParseGetVoiceProfileResponse(rsp *http.Response) (*GetVoiceProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoiceProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetVoiceProfileApiResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
